Project 2 Report

Anthony Gendreau
John Madden

1. Architecture 
The server runs a main thread that listens for clients connecting. As soon as a client connects, the main thread spawns off a new thread to handle that specific client. All of the threads share a common resource, the database file. To synchronize reads and writes, we use a strict mutex lock on this resource specifying that when a thread writes to the file it has a lock and no thread is allowed to write to or read from the file until it is unlocked.

2. Struct to Carry Messages
The structure we created is as follows:
typedef struct Message
{
    enum Message_type type;
    int id_len;
    int length;
    char *client_id;
    char *data;
} Message;


3. Pthreads vs select()
For our server we chose to use pthreads instead of select(). The main difference between the two from our standpoint is that with pthreads the programmer must handle synchronization but with select() the function to handle clients is more complicated. Since the only shared resource was the database file, synchronization was not a difficult problem making pthreads simpler to implement than select(). There is also a concern about pthreads requiring extra resources for each new thread but we did not feel that this would be an issue for this particular project.
4.Interface
We created an interface that gives the user options to connect, set his or her coordinates, get coordinates, get history, leave, or quit. These options are displayed to the user in a numbered list and the user selects the option of his or her choosing by typing in the corresponding number (1 through 5). Our interface includes error checking to inform the user if they have entered an invalid command.

5. Unannounced Leaves
With pthreads we were able to die cast threads from one another so that when a thread dies it does not also kill the main thread which would kill the server end of the program. Whenever a thread dies, the last thing it does is modify the entry in the database file for the client it is/was connected to, setting the 'status' of that client to inactive. This way, if the client left without announcing a leave, the database file still shows the client with that Id as inactive so that they would be able to re-connect. Otherwise when the client tried to re-connect, the server would see their status as still active and report to them that their "Id is already taken".
